{"meta":{"title":"CarlSack Blog","subtitle":"","description":"CarlSack Blog","author":"CarlSack","url":"https://carlsack.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2023-08-03T19:20:20.172Z","updated":"2023-08-03T16:35:05.179Z","comments":true,"path":"categories/index.html","permalink":"https://carlsack.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-08-03T19:20:20.172Z","updated":"2023-08-03T16:33:49.579Z","comments":true,"path":"tags/index.html","permalink":"https://carlsack.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Prometheus 基础介绍","slug":"promethus基础","date":"2023-08-03T07:35:21.000Z","updated":"2023-08-04T06:35:57.656Z","comments":true,"path":"2023/08/03/promethus基础/","link":"","permalink":"https://carlsack.github.io/2023/08/03/promethus%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Prometheus监控报警系统什么是Prometheus?Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。Prometheus目前在开源社区相当活跃。Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。 Prometheus的特点 多维度数据模型。 灵活的查询语言。 不依赖分布式存储，单个服务器节点是自主的。 通过基于HTTP的pull方式采集时序数据。 可以通过中间网关进行时序列数据推送。 通过服务发现或者静态配置来发现目标服务对象。 支持多种多样的图表和界面展示，比如Grafana等。 官网地址：https://prometheus.io/ 架构图 基本原理Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)。 服务过程 Prometheus Daemon负责定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。 Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。 Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。 PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。 Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。 三大套件 Server 主要负责数据采集和存储，提供PromQL查询语言的支持。 Alertmanager 警告管理器，用来进行报警。 Push Gateway 支持临时性Job主动推送指标的中间网关。 监控指标介绍nohup .&#x2F;prometheus 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp; Prometheus监控数据格式 1、Prometheus metrics的概念 2、k&#x2F;v的数据形式 3、Prometheus exporter的使用（pull形式采集数据） 4、Prometheus pushgateway的入门介绍（push形式采集数据） Prometheus监控中，对于采集过来的数据，统一称为metrics数据 Metrics，熟悉大数据系统的不可能没听过说过metrics，当我们需要为某个系统某个服务做监控、做统计，就需要用到Metrics。 Metrics是一种采样数据的总称（metrics并不代表某一种具体的数据格式，是一种对于度量计算单位的抽象） metrics的几种主要的类型Gauges类型 最简单的度量指标，只有一个简单的返回值，或者叫瞬时状态，例如，我们想衡量一个的处理队列中任务的个数用更简单的方式举个例子 例如：如果我要监控硬盘容量或者内存的使用量，那么就应该使用Gauges的metrics格式来度量 因为硬盘的容量或者内存的使用量是随着时间的推移不断的瞬时 没有规则的 变化 这种变化没有规律，当前是多少，采集回来就是多少 既不能肯定是 一直持续增长，也不能肯定是一直降低 是多少就是多少，这种就是Gauges使用类型的代表 如图所示CPU的上下浮动就是采集使用Gauge形式的 metrics数据 没有规律 Counters类型 Counter就是计数器，从数据量0开始累计计算，在理想状态下，只能是永远的增持，不会降低（一些特殊情况另说） 举个例子来说 比如对用户访问量的采样数据 我们的产品被用户访问一次就是1过了10分钟后积累到100 过一天后积累到20000 一周后积累到100000-150000 如下图展示的。Counter数据 是从0开始，一直不断的积累，累加下去的，所以理想状态下，不可能出现任何降低的状况 最多只可能是一只保持不变（例如：用户不在访问了，那么当前累积的总访问量，会以一条水平线的状态保持下去，直到再次被访问） 如下图展示的就是一个counter类型的metrics数据采集。采集的是用户的访问累积量 Histograms类型 Histograms统计数据的分布情况。比如最小值，最大值，中间值，还有中位数，75百分位，90百分位，95百分位，98百分位，99百分位，和99.9百分位的值（percentiles）。 这是一种特殊的metrics数据类型，代表的是一种 近似的百分比估算数值 介绍什么是Histogram数据 histogram类型（prometheus中，其实提供了一个基于histogram算法的函数可以直接使用）可以分别统计出全部用户的响应时间中&#x3D;0.05秒的量有多少 00.05秒的有多少，&gt;2秒的有多少 &gt;10秒的有多少&#x3D;&gt;1% 可以很清晰的看到当前系统中，处于基本正常状态的有多少百分比的用户（或者是请求）多少处于速度极快的用户，多少处于慢请求或者有问题的请求 k&#x2F;v的数据形式Prometheus的数据类型就是依赖于 metrics的类型来计算的 而对于采集回来的数据类型，必须要以一种具体的数据格式供查看和使用 看一下一个exporter采集来的服务器上的k&#x2F;v形式metrics数据 当一个exporter（node_exporter）被安装和运行在被监控的服务器上后 使用简单的curl命令就可以看到exporter采集到的metrics数据的样子，以k&#x2F;v的形式展现和保存 curl localhost:9100&#x2F;metrics 如上图所示curl之后的结果输出 Prometheus_server 带#的行是注释行用来解释下面这一项k&#x2F;v数值 是什么采样的数据 而真正关心的是数据 用空格分开KEY&#x2F;Value数据 第一个代表的是当前采集的最大文件句柄数是65535 第二个代表的是当前采集的被打开的文件句柄数是10 另外 再看下这里 第二行#告诉我们了这一项数据的metrics类型属于gauge exporter的使用官网提供了丰富的成型exporter插件可以使用 举几个例子 pushgateway的概念介绍 exporter是首先安装在被监控服务器上运行在后台 然后自动采集系统数据，本身又是一个HTTP_server可以被Prometheus服务器 定时去HTTP GET取得数据属于pull的形式 如果把这个过程反过来 push的形式十八pushgatewat安装在客户端或者服务端（其实装哪里都无所谓） pushgateway本身也是一个http服务器 运维通过自己的脚本程序 抓自己想要的监控数据，然后推送到pushgateway再由pushgateway推送到prometheus服务端是一个反过来的被动模式 已经有了那么强大的pull形式的node_exporter采集，为什么还需要一个pushgateway的形式呢？ 1、exporter虽然采集类型已经很丰富了，但是我们依然需要很多自制的监控数据，非规则化的自定制的 2、exporter由于数据类型采集量大，其实很多数据或者说大部分数据其实我们监控中真的用不到，用pushgateway是定义一项数据就采集着一种节省资源 3、一个新的自定义的pushgateway脚本开发远远比开发一个全新的exporter简单快速的多的多！！！（exporter的开发需要使用真正的编程语言，shell这种快速脚本是不行的，而且需要了解很多Prometheus自定义的编程格式才能开始制作工作量很大） 4、exporter虽然已经很丰富了，但是依然有很多的我们需要的采集形式，exporter无法提供，或者说现有的expoter还不支持，但是如果使用pushgateway的形式就可以任意灵活想做什么都可以做到，而且极快 内存指标介绍内存指标有 VSS、RSS、PSS、USS，他们的含义分别是： VSS：Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS：Resident Set Size 实际使用物理内存（包含共享库占用的内存） PSS：Proportional Set Size 实际使用的物理内存（按比例分配共享库占用的内存） USS：Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） 一般来说内存占用大小有如下规律：VSS &gt;&#x3D; RSS &gt;&#x3D; PSS &gt;&#x3D; USS，一般测试中关注的比较多的是 PSS 这个指标。 容器监控cadvisor 的安装使用 docker pull 下载最新版本的 cadvisor docker pull google&#x2F;cadvisor:latest 使用 docker run 启动 （建议放在脚本中启动 vi cadvisor-start.sh） 12345678910docker run \\ --volume=/:/rootfs:ro \\ --volume=/var/run:/var/run:rw \\ --volume=/sys:/sys:ro \\ --volume=/var/lib/docker/:/var/lib/docker:ro \\ --volume=/dev/disk/:/dev/disk:ro \\ --publish=18104:8080\\ --detach=true \\ --name=cadvisor \\ google/cadvisor:latest 当启动成功后，使用 docker ps 你会看到 cadvisor 的启动情况 windows监控 windows_exporter 支持 Windows Server 2008R2 以及之后的版本, 和桌面版本的 Windows 7 以及之后的版本 Linux监控 node_exporter grafana 图形化监控centos安装grafana12wget https://dl.grafana.com/oss/release/grafana-8.0.3-1.x86_64.rpmsudo yum install grafana-8.0.3-1.x86_64.rpm PromSQL语法1.获取cpu使用率1100-(avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m])) by(instance) *100) 其中irate函数:irate取的是在指定时间范围内的最近两个数据点来算速率 其中by函数相当于关系型数据库中的group by函数 2.获取内存使用率1100-(node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes)/node_memory_MemTotal_bytes*100 3.count函数用于进行统计或者进行判断,比如判断值大小,为真返回1,否则返回null,no data cpu使用率: 1100-(avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m])) by(instance) *100) 内存使用率： 1100 - (node_memory_MemFree_bytes+node_memory_Buffers_bytes+node_memory_Cached_bytes)/node_memory_MemTotal_bytes*100 硬盘使用率： 1100-node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;,fstype=~&quot;ext4|rootfs&quot;&#125;/node_filesystem_size_bytes&#123;mountpoint=&quot;/&quot;,fstype=~&quot;ext4|rootfs&quot;&#125;*100 监控systemctl管理的系统服务运行状态 1./node_exporter --collector.systemd --collector.systemd.unit-whitelist=(logstash|docker|sshd).service PromQL查询node_systemd_unit_state可以看到服务的运行状态 [附录1]基于docker封装prometheus解决时区问题一、概述官方dockerhub上面的prometheus，下载命令如下： docker pull prom&#x2F;prometheus 发现它的时区为：UTC，我需要更改为CST，也就是中国上海时区。 发现修改变量TZ&#x3D;Asia&#x2F;Shanghai，修改&#x2F;etc&#x2F;localtime 文件都无法修改时区，均失败了。 那么解决办法，就只有自己封装prometheus镜像了。 二、启动prometheus环境说明 操作系统：centos 7.6 docker版本：20.10.7 ip地址：192.168.0.107 封装prometheus目录结构新建目录&#x2F;opt&#x2F;myprometheus，目录结构如下： 123./├── dockerfile└── prometheus-2.28.0.linux-amd64.tar.gz dockerfile内容 12345678910111213FROM centos:7ADD prometheus-2.28.0.linux-amd64.tar.gz /RUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \\ mv /prometheus-2.28.0.linux-amd64 /prometheusWORKDIR /prometheusENTRYPOINT [ &quot;/prometheus/prometheus&quot; ]CMD [ &quot;--config.file=/prometheus/prometheus.yml&quot;, \\ &quot;--storage.tsdb.path=/prometheus/data&quot;, \\ &quot;--web.console.libraries=/prometheus/console_libraries&quot;, \\ &quot;--web.enable-lifecycle&quot;, \\ &quot;--web.console.templates=/prometheus/consoles&quot; ] prometheus-2.28.0.linux-amd64.tar.gz 是从官方下载的，链接如下：https://prometheus.io/download/ 生成镜像1docker build -t myprometheus:v1 . 启动镜像创建持久化目录1mkdir -p /data/prometheus 后台启动12345docker run -d \\ --restart=always \\ --name prometheus \\ -p 9090:9090 \\ myprometheus:v1 等待几秒，拷贝容器文件1docker cp prometheus:/prometheus/ /data/prometheus 删除容器1docker rm -f prometheus 挂载目录启动123456docker run -d \\ --restart=always \\ --name prometheus \\ -p 9090:9090 \\ -v /data/prometheus:/prometheus \\ myprometheus:v1 查看时区1234docker exec -it prometheus dateThu Jul 30 17:54:37 CST 2020 发现时区是正确的。 访问页面http://192.168.0.107:9090 另外再介绍一下alertmanager修改时区，镜像下载命令为： 1docker pull prom/alertmanager 那么启动命令为： 12345678910mkdir -p /data/alertmanager /data/alertmanager/storagedocker run -d \\ -p 9093:9093 \\ --name alertmanager \\ --restart=always \\ -v /etc/localtime:/etc/localtime \\ -v /data/alertmanager:/etc/alertmanager \\ -v /data/alertmanager/storage:/alertmanager \\ prom/alertmanager 这里直接将&#x2F;etc&#x2F;localtime文件，挂载一下即可。 [附录2]consul服务发现问题 会发现 Prometheus 同时加载出来了默认服务 consul，这个是不需要的。 默认只显示 job 及 instance 两个标签，其他标签都默认属于 before relabeling 下，有些必要的服务信息，也想要在标签中展示，该如何操作呢？ 如果需要自定义一些标签，例如 team、group、project 等关键分组信息，方便后边 alertmanager 进行告警规则匹配，该如何处理呢？ 所有 Consul 中注册的 Service 都会默认加载到 Prometheus 下配置的 consul_prometheus 组，如果有多种类型的 exporter，如何在Prometheus 中配置分配给指定类型的组，方便直观的区别它们？ [附录3] consul 服务注册，依赖于json文件123456789101112131415161718192021222324[root@prometheus consul]# cat node-example.json&#123; &quot;ID&quot;: &quot;node-exporter-192.168.31.132&quot;, &quot;Name&quot;: &quot;node-exporter-192.168.31.132&quot;, &quot;Tags&quot;: [ &quot;node-exporter&quot; ], &quot;Address&quot;: &quot;192.168.31.132&quot;, &quot;Port&quot;: 9100, &quot;Meta&quot;: &#123; &quot;app&quot;: &quot;Linux&quot;, &quot;team&quot;: &quot;cloudgroup&quot;, &quot;project&quot;: &quot;Linux-service&quot; &#125;, &quot;EnableTagOverride&quot;: false, &quot;Check&quot;: &#123; &quot;HTTP&quot;: &quot;http://192.168.31.132:9100/metrics&quot;, &quot;Interval&quot;: &quot;5s&quot; &#125;, &quot;Weights&quot;: &#123; &quot;Passing&quot;: 10, &quot;Warning&quot;: 1 &#125;&#125; 1234567891011121314151617181920212223242526[root@prometheus consul]# cat docker-example.json&#123; &quot;ID&quot;: &quot;cadvisor-exporter-192.168.31.138&quot;, &quot;Name&quot;: &quot;cadvisor-exporter-192.168.31.138&quot;, &quot;Tags&quot;: [ &quot;cadvisor-exporter&quot; ], &quot;Address&quot;: &quot;192.168.31.138&quot;, &quot;Port&quot;: 18104, &quot;Meta&quot;: &#123; &quot;app&quot;: &quot;docker&quot;, &quot;team&quot;: &quot;cloudgroup&quot;, &quot;project&quot;: &quot;docker-service&quot; &#125;, &quot;EnableTagOverride&quot;: false, &quot;Check&quot;: &#123; &quot;HTTP&quot;: &quot;http://192.168.31.138:18104/metrics&quot;, &quot;Interval&quot;: &quot;1s&quot; &#125;, &quot;Weights&quot;: &#123; &quot;Passing&quot;: 10, &quot;Warning&quot;: 1 &#125;&#125; 123456789101112131415161718192021222324[root@prometheus consul]# cat windows-example.json&#123; &quot;ID&quot;: &quot;windows-exporter-192.168.31.138&quot;, &quot;Name&quot;: &quot;windows-exporter-192.168.31.138&quot;, &quot;Tags&quot;: [ &quot;windows-exporter&quot; ], &quot;Address&quot;: &quot;192.168.31.138&quot;, &quot;Port&quot;: 9100, &quot;Meta&quot;: &#123; &quot;app&quot;: &quot;windows&quot;, &quot;team&quot;: &quot;cloudgroup&quot;, &quot;project&quot;: &quot;windows-service&quot; &#125;, &quot;EnableTagOverride&quot;: false, &quot;Check&quot;: &#123; &quot;HTTP&quot;: &quot;http://192.168.31.138:9100/metrics&quot;, &quot;Interval&quot;: &quot;5s&quot; &#125;, &quot;Weights&quot;: &#123; &quot;Passing&quot;: 10, &quot;Warning&quot;: 1 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/bin/bashconsul_ip=192.168.31.132function quit_and_checkip()&#123; VALID_CHECK=$( echo $1| awk -F &quot;.&quot; &#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print &quot;yes&quot;&#125;&#x27; ) if [[ $1 = &quot;q&quot; || $1 = &quot;quit&quot; ]];then exit elif ! echo $1| grep -E &quot;^[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;$&quot; &gt; /dev/null ;then echo &quot;IP $1 格式有问题!&quot; exit elif [ ! $&#123;VALID_CHECK:-no&#125; == &quot;yes&quot; ];then echo &quot;IP $1 有问题!&quot; exit fi&#125;#cd /prometheus/consul_register/read -n 1 -p &quot;你需要注册还是删除节点,1代表增加,2代表删除:&quot; service_numif [ $service_num -eq 1 ];then echo &quot;&quot; read -n 1 -p &quot;请输入你添加的节点类型编号,1-docker,2-linux,3-windows:&quot; service_type echo &quot;&quot; case $service_type in &quot;1&quot;) while true do read -p &quot;输入注册节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip cp docker-example.json cadvisor-exporter-$service_ip.json sed -i &quot;s/192.168.31.138/$service_ip/g&quot; cadvisor-exporter-$service_ip.json curl --request PUT --data @cadvisor-exporter-$service_ip.json http://$consul_ip:8500/v1/agent/service/register?replace-existing-checks=1 echo &quot;节点cadvisor-exporter-$service_ip注册成功&quot; done ;; &quot;2&quot;) while true do read -p &quot;输入注册节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip cp node.json node-exporter-$service_ip.json sed -i &quot;s/192.168.31.132/$service_ip/g&quot; node-exporter-$service_ip.json curl --request PUT --data @node-exporter-$service_ip.json http://$consul_ip:8500/v1/agent/service/register?replace-existing-checks=1 echo &quot;节点node-exporter-$service_ip注册成功&quot; done ;; &quot;3&quot;) while true do read -p &quot;输入注册节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip cp windows-example.json windows-exporter-$service_ip.json sed -i &quot;s/192.168.31.138/$service_ip/g&quot; windows-exporter-$service_ip.json curl --request PUT --data @windows-exporter-$service_ip.json http://$consul_ip:8500/v1/agent/service/register?replace-existing-checks=1 echo &quot;节点windows-exporter-$service_ip注册成功&quot; done ;; *) echo &quot;输入编号类型错误&quot; ;; esacelif [ $service_num -eq 2 ];then echo &quot;&quot; read -n 1 -p &quot;请输入你删除的节点类型编号,1-docker,2-linux,3-windows:&quot; service_type echo &quot;&quot; case $service_type in &quot;1&quot;) while true do read -p &quot;输入需要删除节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip curl -X PUT http://$consul_ip:8500/v1/agent/service/deregister/cadvisor-exporter-$service_ip rm -rf cadvisor-exporter-$service_ip.json echo &quot;节点cadvisor-exporter-$service_ip已删除&quot; done ;; &quot;2&quot;) while true do read -p &quot;输入需要删除节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip curl -X PUT http://$consul_ip:8500/v1/agent/service/deregister/node-exporter-$service_ip rm -rf node-exporter-$service_ip.json echo &quot;节点node-exporter-$service_ip已删除&quot; done ;; &quot;3&quot;) while true do read -p &quot;输入需要删除节点的IP,输入q或quit退出:&quot; service_ip quit_and_checkip $service_ip curl -X PUT http://$consul_ip:8500/v1/agent/service/deregister/windows-exporter-$service_ip rm -rf windows-exporter-$service_ip.json echo &quot;节点windows-exporter-$service_ip已删除&quot; done ;; *) echo &quot;输入类型错误&quot; ;; esacfi","categories":[{"name":"工作","slug":"工作","permalink":"https://carlsack.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"prometheus","slug":"prometheus","permalink":"https://carlsack.github.io/tags/prometheus/"},{"name":"监控","slug":"监控","permalink":"https://carlsack.github.io/tags/%E7%9B%91%E6%8E%A7/"}],"author":"CarlSack"}],"categories":[{"name":"工作","slug":"工作","permalink":"https://carlsack.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"prometheus","slug":"prometheus","permalink":"https://carlsack.github.io/tags/prometheus/"},{"name":"监控","slug":"监控","permalink":"https://carlsack.github.io/tags/%E7%9B%91%E6%8E%A7/"}]}